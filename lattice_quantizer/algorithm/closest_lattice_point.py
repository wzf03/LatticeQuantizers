import numpy as np
from numba import float64, int64, njit


@njit(
    [
        int64[:](float64[:, :], float64[:]),
    ],
    cache=True,
)
def closest_lattice_point(G: np.ndarray, r: np.ndarray) -> np.ndarray:
    """
    Find the closest lattice point to a received vector r in the lattice generated by G.
    Args:
        G: a lower triangular n x n generator matrix with positive diagonal entries
        r: received vector
    """
    n = G.shape[0]

    d = np.full(n, n - 1)
    u = np.zeros(n, dtype=np.int64)
    u_hat = np.zeros(n, dtype=np.int64)
    p = np.zeros(n)
    delta = np.zeros(n, dtype=np.int64)
    lambda_ = np.zeros(n + 1)
    F = np.zeros((n, n))

    C = np.inf
    i = n
    F[n - 1, :] = r

    while True:
        while True:
            if i != 0:
                i = i - 1
                for j in range(d[i], i, -1):
                    F[j - 1, i] = F[j, i] - u[j] * G[j, i]
                p[i] = F[i, i] / G[i, i]
                u[i] = np.round(p[i])
                y = (p[i] - u[i]) * G[i, i]
                delta[i] = np.sign(y)
                lambda_[i] = lambda_[i + 1] + y * y
            else:
                u_hat[:] = u
                C = lambda_[0]

            if not (lambda_[i] < C):
                break

        m = i

        while True:
            if i == n - 1:
                return u_hat
            i = i + 1
            u[i] += delta[i]
            delta[i] = -delta[i] - np.sign(delta[i])
            y = (p[i] - u[i]) * G[i, i]
            lambda_[i] = lambda_[i + 1] + y * y

            if lambda_[i] < C:
                break

        d[m:i] = i
        for j in range(m - 1, -1, -1):
            if d[j] < i:
                d[j] = i
            else:
                break
